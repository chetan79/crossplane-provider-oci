/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type NetworkSecurityGroupSecurityRuleIcmpOptionsObservation struct {
}

type NetworkSecurityGroupSecurityRuleIcmpOptionsParameters struct {

	// +kubebuilder:validation:Optional
	Code *float64 `json:"code,omitempty" tf:"code,omitempty"`

	// +kubebuilder:validation:Required
	Type *float64 `json:"type" tf:"type,omitempty"`
}

type NetworkSecurityGroupSecurityRuleObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	IsValid *bool `json:"isValid,omitempty" tf:"is_valid,omitempty"`

	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`
}

type NetworkSecurityGroupSecurityRuleParameters struct {

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`

	// +kubebuilder:validation:Optional
	DestinationType *string `json:"destinationType,omitempty" tf:"destination_type,omitempty"`

	// +kubebuilder:validation:Required
	Direction *string `json:"direction" tf:"direction,omitempty"`

	// +kubebuilder:validation:Optional
	IcmpOptions []NetworkSecurityGroupSecurityRuleIcmpOptionsParameters `json:"icmpOptions,omitempty" tf:"icmp_options,omitempty"`

	// +crossplane:generate:reference:type=NetworkSecurityGroup
	// +kubebuilder:validation:Optional
	NetworkSecurityGroupID *string `json:"networkSecurityGroupId,omitempty" tf:"network_security_group_id,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkSecurityGroupIDRef *v1.Reference `json:"networkSecurityGroupIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	NetworkSecurityGroupIDSelector *v1.Selector `json:"networkSecurityGroupIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// +kubebuilder:validation:Optional
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// +kubebuilder:validation:Optional
	SourceType *string `json:"sourceType,omitempty" tf:"source_type,omitempty"`

	// +kubebuilder:validation:Optional
	Stateless *bool `json:"stateless,omitempty" tf:"stateless,omitempty"`

	// +kubebuilder:validation:Optional
	TCPOptions []NetworkSecurityGroupSecurityRuleTCPOptionsParameters `json:"tcpOptions,omitempty" tf:"tcp_options,omitempty"`

	// +kubebuilder:validation:Optional
	UDPOptions []NetworkSecurityGroupSecurityRuleUDPOptionsParameters `json:"udpOptions,omitempty" tf:"udp_options,omitempty"`
}

type NetworkSecurityGroupSecurityRuleTCPOptionsObservation struct {
}

type NetworkSecurityGroupSecurityRuleTCPOptionsParameters struct {

	// +kubebuilder:validation:Optional
	DestinationPortRange []TCPOptionsDestinationPortRangeParameters `json:"destinationPortRange,omitempty" tf:"destination_port_range,omitempty"`

	// +kubebuilder:validation:Optional
	SourcePortRange []TCPOptionsSourcePortRangeParameters `json:"sourcePortRange,omitempty" tf:"source_port_range,omitempty"`
}

type NetworkSecurityGroupSecurityRuleUDPOptionsDestinationPortRangeObservation struct {
}

type NetworkSecurityGroupSecurityRuleUDPOptionsDestinationPortRangeParameters struct {

	// +kubebuilder:validation:Required
	Max *float64 `json:"max" tf:"max,omitempty"`

	// +kubebuilder:validation:Required
	Min *float64 `json:"min" tf:"min,omitempty"`
}

type NetworkSecurityGroupSecurityRuleUDPOptionsObservation struct {
}

type NetworkSecurityGroupSecurityRuleUDPOptionsParameters struct {

	// +kubebuilder:validation:Optional
	DestinationPortRange []NetworkSecurityGroupSecurityRuleUDPOptionsDestinationPortRangeParameters `json:"destinationPortRange,omitempty" tf:"destination_port_range,omitempty"`

	// +kubebuilder:validation:Optional
	SourcePortRange []NetworkSecurityGroupSecurityRuleUDPOptionsSourcePortRangeParameters `json:"sourcePortRange,omitempty" tf:"source_port_range,omitempty"`
}

type NetworkSecurityGroupSecurityRuleUDPOptionsSourcePortRangeObservation struct {
}

type NetworkSecurityGroupSecurityRuleUDPOptionsSourcePortRangeParameters struct {

	// +kubebuilder:validation:Required
	Max *float64 `json:"max" tf:"max,omitempty"`

	// +kubebuilder:validation:Required
	Min *float64 `json:"min" tf:"min,omitempty"`
}

type TCPOptionsDestinationPortRangeObservation struct {
}

type TCPOptionsDestinationPortRangeParameters struct {

	// +kubebuilder:validation:Required
	Max *float64 `json:"max" tf:"max,omitempty"`

	// +kubebuilder:validation:Required
	Min *float64 `json:"min" tf:"min,omitempty"`
}

type TCPOptionsSourcePortRangeObservation struct {
}

type TCPOptionsSourcePortRangeParameters struct {

	// +kubebuilder:validation:Required
	Max *float64 `json:"max" tf:"max,omitempty"`

	// +kubebuilder:validation:Required
	Min *float64 `json:"min" tf:"min,omitempty"`
}

// NetworkSecurityGroupSecurityRuleSpec defines the desired state of NetworkSecurityGroupSecurityRule
type NetworkSecurityGroupSecurityRuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     NetworkSecurityGroupSecurityRuleParameters `json:"forProvider"`
}

// NetworkSecurityGroupSecurityRuleStatus defines the observed state of NetworkSecurityGroupSecurityRule.
type NetworkSecurityGroupSecurityRuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        NetworkSecurityGroupSecurityRuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// NetworkSecurityGroupSecurityRule is the Schema for the NetworkSecurityGroupSecurityRules API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,ocijet}
type NetworkSecurityGroupSecurityRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              NetworkSecurityGroupSecurityRuleSpec   `json:"spec"`
	Status            NetworkSecurityGroupSecurityRuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// NetworkSecurityGroupSecurityRuleList contains a list of NetworkSecurityGroupSecurityRules
type NetworkSecurityGroupSecurityRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []NetworkSecurityGroupSecurityRule `json:"items"`
}

// Repository type metadata.
var (
	NetworkSecurityGroupSecurityRule_Kind             = "NetworkSecurityGroupSecurityRule"
	NetworkSecurityGroupSecurityRule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: NetworkSecurityGroupSecurityRule_Kind}.String()
	NetworkSecurityGroupSecurityRule_KindAPIVersion   = NetworkSecurityGroupSecurityRule_Kind + "." + CRDGroupVersion.String()
	NetworkSecurityGroupSecurityRule_GroupVersionKind = CRDGroupVersion.WithKind(NetworkSecurityGroupSecurityRule_Kind)
)

func init() {
	SchemeBuilder.Register(&NetworkSecurityGroupSecurityRule{}, &NetworkSecurityGroupSecurityRuleList{})
}
