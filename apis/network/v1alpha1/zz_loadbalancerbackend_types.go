/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type LoadBalancerBackendObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type LoadBalancerBackendParameters struct {

	// The name of the backend set to which to add the backend server.  Example: example_backend_set
	// +kubebuilder:validation:Required
	BackendSetName *string `json:"backendSetName" tf:"backend_set_name,omitempty"`

	// The IP address of the backend server. Example: 10.0.0.3
	// +kubebuilder:validation:Optional
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// (Updatable) Whether the network load balancer should treat this server as a backup unit. If true, then the network load balancer forwards no ingress traffic to this backend server unless all other backend servers not marked as "isBackup" fail the health check policy.  Example: false
	// +kubebuilder:validation:Optional
	IsBackup *bool `json:"isBackup,omitempty" tf:"is_backup,omitempty"`

	// (Updatable) Whether the network load balancer should drain this server. Servers marked "isDrain" receive no incoming traffic.  Example: false
	// +kubebuilder:validation:Optional
	IsDrain *bool `json:"isDrain,omitempty" tf:"is_drain,omitempty"`

	// (Updatable) Whether the network load balancer should treat this server as offline. Offline servers receive no incoming traffic.  Example: false
	// +kubebuilder:validation:Optional
	IsOffline *bool `json:"isOffline,omitempty" tf:"is_offline,omitempty"`

	// Optional unique name identifying the backend within the backend set. If not specified, then one will be generated. Example: webServer1
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The OCID of the network load balancer to update.
	// +crossplane:generate:reference:type=LoadBalancerNetworkLoadBalancer
	// +kubebuilder:validation:Optional
	NetworkLoadBalancerID *string `json:"networkLoadBalancerId,omitempty" tf:"network_load_balancer_id,omitempty"`

	// Reference to a LoadBalancerNetworkLoadBalancer to populate networkLoadBalancerId.
	// +kubebuilder:validation:Optional
	NetworkLoadBalancerIDRef *v1.Reference `json:"networkLoadBalancerIdRef,omitempty" tf:"-"`

	// Selector for a LoadBalancerNetworkLoadBalancer to populate networkLoadBalancerId.
	// +kubebuilder:validation:Optional
	NetworkLoadBalancerIDSelector *v1.Selector `json:"networkLoadBalancerIdSelector,omitempty" tf:"-"`

	// The communication port for the backend server.  Example: 8080
	// +kubebuilder:validation:Required
	Port *float64 `json:"port" tf:"port,omitempty"`

	// The IP OCID/Instance OCID associated with the backend server. Example: ocid1.privateip..oc1.<var>&lt;unique_ID&gt;</var>
	// +kubebuilder:validation:Optional
	TargetID *string `json:"targetId,omitempty" tf:"target_id,omitempty"`

	// (Updatable) The network load balancing policy weight assigned to the server. Backend servers with a higher weight receive a larger proportion of incoming traffic. For example, a server weighted '3' receives three times the number of new connections as a server weighted '1'. For more information about load balancing policies, see How Network Load Balancing Policies Work.  Example: 3
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

// LoadBalancerBackendSpec defines the desired state of LoadBalancerBackend
type LoadBalancerBackendSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     LoadBalancerBackendParameters `json:"forProvider"`
}

// LoadBalancerBackendStatus defines the observed state of LoadBalancerBackend.
type LoadBalancerBackendStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        LoadBalancerBackendObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// LoadBalancerBackend is the Schema for the LoadBalancerBackends API. Provides the Backend resource in Oracle Cloud Infrastructure Network Load Balancer service
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type LoadBalancerBackend struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LoadBalancerBackendSpec   `json:"spec"`
	Status            LoadBalancerBackendStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// LoadBalancerBackendList contains a list of LoadBalancerBackends
type LoadBalancerBackendList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LoadBalancerBackend `json:"items"`
}

// Repository type metadata.
var (
	LoadBalancerBackend_Kind             = "LoadBalancerBackend"
	LoadBalancerBackend_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: LoadBalancerBackend_Kind}.String()
	LoadBalancerBackend_KindAPIVersion   = LoadBalancerBackend_Kind + "." + CRDGroupVersion.String()
	LoadBalancerBackend_GroupVersionKind = CRDGroupVersion.WithKind(LoadBalancerBackend_Kind)
)

func init() {
	SchemeBuilder.Register(&LoadBalancerBackend{}, &LoadBalancerBackendList{})
}
